import { useEffect, useRef } from "react";
import Phaser from "phaser";
import { createSeedIcon } from "../gameFunctions/createSeedIcon";
import { GlobalVariables } from "../game/GlobalVariables";

const gameState = {
    gridSize: 80, // Size of each grid cell
    rows: 5, // Number of rows in the grid
    cols: 6, // Number of columns in the grid
};

export default function PhaserGame() {
    const gameContainer = useRef(null);

    useEffect(() => {
        if (!gameContainer.current) return;

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: gameContainer.current,
            scene: {
                preload: preload,
                create: create,
                update: update,
            },
        };

        const game = new Phaser.Game(config);

        function preload() {
            this.load.image("background", "/assets/Background.png");
            this.load.image("seed", "/assets/Seed.png");
            this.load.image("plant", "/assets/Plant 1.png");
            this.load.image("ground", "/assets/Ground 1.png");
            this.load.audio("success", "/assets/Complete.mp3");
            this.load.audio("fail", "/assets/Fail.wav");
        }

        function create() {
            // Background
            this.add.image(400, 300, "background").setScale(1.5);

            // Toolbar background
            this.add.rectangle(400, 50, 800, 100, 0x222222).setDepth(5);

            // Create 10 grounds in the toolbar
            const toolbarGrounds = [];
            for (let i = 0; i < 10; i++) {
                const ground = this.add.image(50 + 60, 50, "ground").setScale(0.6).setDepth(10);
                ground.setInteractive();
                this.input.setDraggable(ground);
                toolbarGrounds.push(ground);
            }

            // Create a grid of positions for placing grounds
            const grid = [];
            for (let row = 0; row < gameState.rows; row++) {
                for (let col = 0; col < gameState.cols; col++) {
                    const x = gameState.gridSize * (col + 1); // Calculate X position
                    const y = gameState.gridSize * (row + 2); // Calculate Y position
                    const ground = this.add.image(x, y, "ground").setScale(0.6).setAlpha(0); // Set invisible initially
                    grid.push({ x, y, ground, placed: false });
                }
            }

            // Handle Dragging
            this.input.on("drag", (pointer, gameObject, dragX, dragY) => {
                gameObject.x = dragX;
                gameObject.y = dragY;
                gameObject.setAlpha(0.5);
            });

            // Handle Drop (place ground in the nearest grid position)
            this.input.on("dragend", (pointer, gameObject) => {
                if (gameObject.texture.key === "ground") {
                    let placedInZone = false;

                    // Find the closest grid position and check if it is available
                    grid.forEach((gridPos) => {
                        if (!gridPos.placed && Phaser.Math.Distance.Between(gameObject.x, gameObject.y, gridPos.x, gridPos.y) < gameState.gridSize / 2) {
                            // Place the ground in the grid position
                            this.tweens.add({
                                targets: gameObject,
                                x: gridPos.x,
                                y: gridPos.y,
                                duration: 300,
                            });
                            gridPos.placed = true;
                            placedInZone = true;

                            // Mark the ground in the toolbar as used (invisible)
                            gameObject.setAlpha(1); // Set alpha back to 1 after placement
                            gameObject.setInteractive(false); // Make it un-interactive
                            return;
                        }
                    });

                    // If not placed in any valid zone, return it to the toolbar
                    if (!placedInZone) {
                        this.sound.play("fail");
                        gameObject.setAlpha(1);
                        gameObject.x = gameObject.input.dragStartX;
                        gameObject.y = gameObject.input.dragStartY;
                    } else {
                        this.sound.play("success");
                    }
                }
            });
        }

        function update() {}

        return () => {
            game.destroy(true);
        };
    }, []);

    return <div ref={gameContainer} className="w-full h-screen bg-black"></div>;
}
